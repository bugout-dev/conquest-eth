# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : 0.2.4

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress


PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "build", "contracts")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> str:
    return raw_value


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    return ContractContainer(PROJECT, build)


class AllianceRegistry:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "AllianceRegistry"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("AllianceRegistry")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(
        self,
        implementation_address: ChecksumAddress,
        owner_address: ChecksumAddress,
        data: bytes,
        transaction_config,
    ):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(
            implementation_address, owner_address, data, transaction_config
        )
        self.address = deployed_contract.address
        self.contract = deployed_contract
        return deployed_contract.tx

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def verify_contract(self):
        self.assert_contract_is_instantiated()
        contract_class = contract_from_build(self.contract_name)
        contract_class.publish_source(self.contract)

    def owner(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.owner.call(block_identifier=block_number)

    def supports_interface(
        self, id: bytes, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.supportsInterface.call(id, block_identifier=block_number)

    def transfer_ownership(self, new_owner: ChecksumAddress, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.transferOwnership(new_owner, transaction_config)

    def upgrade_to(
        self, new_implementation: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.upgradeTo(new_implementation, transaction_config)

    def upgrade_to_and_call(
        self, new_implementation: ChecksumAddress, data: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.upgradeToAndCall(
            new_implementation, data, transaction_config
        )

    def add_multiple_players_to_alliance(
        self, player_submissions: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.addMultiplePlayersToAlliance(
            player_submissions, transaction_config
        )

    def add_player_to_alliance(
        self, player: ChecksumAddress, nonce: int, signature: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.addPlayerToAlliance(
            player, nonce, signature, transaction_config
        )

    def balance_of(
        self,
        owner: ChecksumAddress,
        id: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.balanceOf.call(owner, id, block_identifier=block_number)

    def balance_of_batch(
        self,
        owners: List,
        ids: List,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.balanceOfBatch.call(
            owners, ids, block_identifier=block_number
        )

    def eject_player_from_alliance(
        self, player: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.ejectPlayerFromAlliance(player, transaction_config)

    def get_alliance_data(
        self,
        player: ChecksumAddress,
        alliance: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getAllianceData.call(
            player, alliance, block_identifier=block_number
        )

    def get_alliance_data_at_slot(
        self,
        player: ChecksumAddress,
        slot: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getAllianceDataAtSlot.call(
            player, slot, block_identifier=block_number
        )

    def have_players_an_alliance_in_common(
        self,
        player1: ChecksumAddress,
        player2: ChecksumAddress,
        timestamp: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.havePlayersAnAllianceInCommon.call(
            player1, player2, timestamp, block_identifier=block_number
        )

    def is_approved_for_all(
        self, arg1: ChecksumAddress, arg2: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.isApprovedForAll(arg1, arg2, transaction_config)

    def join_alliance(
        self, alliance: ChecksumAddress, data: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.joinAlliance(alliance, data, transaction_config)

    def leave_alliance(self, alliance: ChecksumAddress, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.leaveAlliance(alliance, transaction_config)


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.max_fee_per_gas is not None:
        transaction_config["max_fee"] = args.max_fee_per_gas
    if args.max_priority_fee_per_gas is not None:
        transaction_config["priority_fee"] = args.max_priority_fee_per_gas
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        parser.add_argument(
            "--block-number",
            required=False,
            type=int,
            help="Call at the given block number, defaults to latest",
        )
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--max-fee-per-gas",
        default=None,
        help="Max fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--max-priority-fee-per-gas",
        default=None,
        help="Max priority fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )
    parser.add_argument(
        "--value", default=None, help="Value of the transaction in wei(optional)"
    )
    parser.add_argument("--verbose", action="store_true", help="Print verbose output")


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = AllianceRegistry(None)
    result = contract.deploy(
        implementation_address=args.implementation_address,
        owner_address=args.owner_address,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_verify_contract(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.verify_contract()
    print(result)


def handle_owner(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.owner(block_number=args.block_number)
    print(result)


def handle_supports_interface(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.supports_interface(id=args.id, block_number=args.block_number)
    print(result)


def handle_transfer_ownership(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.transfer_ownership(
        new_owner=args.new_owner, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_upgrade_to(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.upgrade_to(
        new_implementation=args.new_implementation,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_upgrade_to_and_call(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.upgrade_to_and_call(
        new_implementation=args.new_implementation,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_add_multiple_players_to_alliance(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.add_multiple_players_to_alliance(
        player_submissions=args.player_submissions,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_add_player_to_alliance(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.add_player_to_alliance(
        player=args.player,
        nonce=args.nonce_arg,
        signature=args.signature,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_balance_of(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.balance_of(
        owner=args.owner, id=args.id, block_number=args.block_number
    )
    print(result)


def handle_balance_of_batch(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.balance_of_batch(
        owners=args.owners, ids=args.ids, block_number=args.block_number
    )
    print(result)


def handle_eject_player_from_alliance(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.eject_player_from_alliance(
        player=args.player, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_get_alliance_data(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.get_alliance_data(
        player=args.player, alliance=args.alliance, block_number=args.block_number
    )
    print(result)


def handle_get_alliance_data_at_slot(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.get_alliance_data_at_slot(
        player=args.player, slot=args.slot, block_number=args.block_number
    )
    print(result)


def handle_have_players_an_alliance_in_common(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    result = contract.have_players_an_alliance_in_common(
        player1=args.player1,
        player2=args.player2,
        timestamp=args.timestamp,
        block_number=args.block_number,
    )
    print(result)


def handle_is_approved_for_all(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.is_approved_for_all(
        arg1=args.arg1, arg2=args.arg2, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_join_alliance(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.join_alliance(
        alliance=args.alliance, data=args.data, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_leave_alliance(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = AllianceRegistry(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.leave_alliance(
        alliance=args.alliance, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for AllianceRegistry")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.add_argument(
        "--implementation-address", required=True, help="Type: address"
    )
    deploy_parser.add_argument("--owner-address", required=True, help="Type: address")
    deploy_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    deploy_parser.set_defaults(func=handle_deploy)

    verify_contract_parser = subcommands.add_parser("verify-contract")
    add_default_arguments(verify_contract_parser, False)
    verify_contract_parser.set_defaults(func=handle_verify_contract)

    owner_parser = subcommands.add_parser("owner")
    add_default_arguments(owner_parser, False)
    owner_parser.set_defaults(func=handle_owner)

    supports_interface_parser = subcommands.add_parser("supports-interface")
    add_default_arguments(supports_interface_parser, False)
    supports_interface_parser.add_argument(
        "--id", required=True, help="Type: bytes4", type=bytes_argument_type
    )
    supports_interface_parser.set_defaults(func=handle_supports_interface)

    transfer_ownership_parser = subcommands.add_parser("transfer-ownership")
    add_default_arguments(transfer_ownership_parser, True)
    transfer_ownership_parser.add_argument(
        "--new-owner", required=True, help="Type: address"
    )
    transfer_ownership_parser.set_defaults(func=handle_transfer_ownership)

    upgrade_to_parser = subcommands.add_parser("upgrade-to")
    add_default_arguments(upgrade_to_parser, True)
    upgrade_to_parser.add_argument(
        "--new-implementation", required=True, help="Type: address"
    )
    upgrade_to_parser.set_defaults(func=handle_upgrade_to)

    upgrade_to_and_call_parser = subcommands.add_parser("upgrade-to-and-call")
    add_default_arguments(upgrade_to_and_call_parser, True)
    upgrade_to_and_call_parser.add_argument(
        "--new-implementation", required=True, help="Type: address"
    )
    upgrade_to_and_call_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    upgrade_to_and_call_parser.set_defaults(func=handle_upgrade_to_and_call)

    add_multiple_players_to_alliance_parser = subcommands.add_parser(
        "add-multiple-players-to-alliance"
    )
    add_default_arguments(add_multiple_players_to_alliance_parser, True)
    add_multiple_players_to_alliance_parser.add_argument(
        "--player-submissions", required=True, help="Type: tuple[]", nargs="+"
    )
    add_multiple_players_to_alliance_parser.set_defaults(
        func=handle_add_multiple_players_to_alliance
    )

    add_player_to_alliance_parser = subcommands.add_parser("add-player-to-alliance")
    add_default_arguments(add_player_to_alliance_parser, True)
    add_player_to_alliance_parser.add_argument(
        "--player", required=True, help="Type: address"
    )
    add_player_to_alliance_parser.add_argument(
        "--nonce-arg", required=True, help="Type: uint32", type=int
    )
    add_player_to_alliance_parser.add_argument(
        "--signature", required=True, help="Type: bytes", type=bytes_argument_type
    )
    add_player_to_alliance_parser.set_defaults(func=handle_add_player_to_alliance)

    balance_of_parser = subcommands.add_parser("balance-of")
    add_default_arguments(balance_of_parser, False)
    balance_of_parser.add_argument("--owner", required=True, help="Type: address")
    balance_of_parser.add_argument(
        "--id", required=True, help="Type: uint256", type=int
    )
    balance_of_parser.set_defaults(func=handle_balance_of)

    balance_of_batch_parser = subcommands.add_parser("balance-of-batch")
    add_default_arguments(balance_of_batch_parser, False)
    balance_of_batch_parser.add_argument(
        "--owners", required=True, help="Type: address[]", nargs="+"
    )
    balance_of_batch_parser.add_argument(
        "--ids", required=True, help="Type: uint256[]", nargs="+"
    )
    balance_of_batch_parser.set_defaults(func=handle_balance_of_batch)

    eject_player_from_alliance_parser = subcommands.add_parser(
        "eject-player-from-alliance"
    )
    add_default_arguments(eject_player_from_alliance_parser, True)
    eject_player_from_alliance_parser.add_argument(
        "--player", required=True, help="Type: address"
    )
    eject_player_from_alliance_parser.set_defaults(
        func=handle_eject_player_from_alliance
    )

    get_alliance_data_parser = subcommands.add_parser("get-alliance-data")
    add_default_arguments(get_alliance_data_parser, False)
    get_alliance_data_parser.add_argument(
        "--player", required=True, help="Type: address"
    )
    get_alliance_data_parser.add_argument(
        "--alliance", required=True, help="Type: address"
    )
    get_alliance_data_parser.set_defaults(func=handle_get_alliance_data)

    get_alliance_data_at_slot_parser = subcommands.add_parser(
        "get-alliance-data-at-slot"
    )
    add_default_arguments(get_alliance_data_at_slot_parser, False)
    get_alliance_data_at_slot_parser.add_argument(
        "--player", required=True, help="Type: address"
    )
    get_alliance_data_at_slot_parser.add_argument(
        "--slot", required=True, help="Type: uint8", type=int
    )
    get_alliance_data_at_slot_parser.set_defaults(func=handle_get_alliance_data_at_slot)

    have_players_an_alliance_in_common_parser = subcommands.add_parser(
        "have-players-an-alliance-in-common"
    )
    add_default_arguments(have_players_an_alliance_in_common_parser, False)
    have_players_an_alliance_in_common_parser.add_argument(
        "--player1", required=True, help="Type: address"
    )
    have_players_an_alliance_in_common_parser.add_argument(
        "--player2", required=True, help="Type: address"
    )
    have_players_an_alliance_in_common_parser.add_argument(
        "--timestamp", required=True, help="Type: uint256", type=int
    )
    have_players_an_alliance_in_common_parser.set_defaults(
        func=handle_have_players_an_alliance_in_common
    )

    is_approved_for_all_parser = subcommands.add_parser("is-approved-for-all")
    add_default_arguments(is_approved_for_all_parser, True)
    is_approved_for_all_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    is_approved_for_all_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    is_approved_for_all_parser.set_defaults(func=handle_is_approved_for_all)

    join_alliance_parser = subcommands.add_parser("join-alliance")
    add_default_arguments(join_alliance_parser, True)
    join_alliance_parser.add_argument("--alliance", required=True, help="Type: address")
    join_alliance_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    join_alliance_parser.set_defaults(func=handle_join_alliance)

    leave_alliance_parser = subcommands.add_parser("leave-alliance")
    add_default_arguments(leave_alliance_parser, True)
    leave_alliance_parser.add_argument(
        "--alliance", required=True, help="Type: address"
    )
    leave_alliance_parser.set_defaults(func=handle_leave_alliance)

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()

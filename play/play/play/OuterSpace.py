# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : 0.2.4

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress


PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "build", "contracts")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> str:
    return raw_value


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    return ContractContainer(PROJECT, build)


class OuterSpace:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "OuterSpace"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("OuterSpace")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(
        self,
        _contract_owner: ChecksumAddress,
        _diamond_cut: List,
        _initializations: List,
        transaction_config,
    ):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(
            _contract_owner, _diamond_cut, _initializations, transaction_config
        )
        self.address = deployed_contract.address
        self.contract = deployed_contract
        return deployed_contract.tx

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def verify_contract(self):
        self.assert_contract_is_instantiated()
        contract_class = contract_from_build(self.contract_name)
        contract_class.publish_source(self.contract)

    def init(self, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.init(transaction_config)

    def add_reward(
        self, location: int, sponsor: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.addReward(location, sponsor, transaction_config)

    def debug_reset_exit_start_time(self, location: int, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.debug_reset_exitStartTime(location, transaction_config)

    def reset_planet(self, location: int, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.resetPlanet(location, transaction_config)

    def get_fleet(
        self,
        fleet_id: int,
        from_: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getFleet.call(
            fleet_id, from_, block_identifier=block_number
        )

    def resolve_fleet(self, fleet_id: int, resolution: Any, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.resolveFleet(fleet_id, resolution, transaction_config)

    def send(
        self, from_: int, quantity: int, to_hash: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.send(from_, quantity, to_hash, transaction_config)

    def send_for(self, launch: Any, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.sendFor(launch, transaction_config)

    def get_planet(
        self, location: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getPlanet.call(location, block_identifier=block_number)

    def get_planet_state(
        self, location: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getPlanetState.call(
            location, block_identifier=block_number
        )

    def get_updated_planet_state(
        self, location: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getUpdatedPlanetState.call(
            location, block_identifier=block_number
        )

    def is_approved_for_all(
        self,
        owner: ChecksumAddress,
        operator: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.isApprovedForAll.call(
            owner, operator, block_identifier=block_number
        )

    def owner_and_ownership_start_time_of(
        self, location: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.ownerAndOwnershipStartTimeOf.call(
            location, block_identifier=block_number
        )

    def owner_of(
        self, location: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.ownerOf.call(location, block_identifier=block_number)

    def safe_transfer_from(
        self,
        from_: ChecksumAddress,
        to: ChecksumAddress,
        location: int,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.safeTransferFrom(from_, to, location, transaction_config)

    def safe_transfer_from(
        self,
        from_: ChecksumAddress,
        to: ChecksumAddress,
        location: int,
        data: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.safeTransferFrom(
            from_, to, location, data, transaction_config
        )

    def set_approval_for_all(
        self, operator: ChecksumAddress, approved: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setApprovalForAll(operator, approved, transaction_config)

    def set_approval_for_all_if_needed_and_call(
        self, operator: ChecksumAddress, data: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setApprovalForAllIfNeededAndCall(
            operator, data, transaction_config
        )

    def transfer_from(
        self,
        from_: ChecksumAddress,
        to: ChecksumAddress,
        location: int,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.transferFrom(from_, to, location, transaction_config)

    def get_alliance_registry(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getAllianceRegistry.call(block_identifier=block_number)

    def get_discovered(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getDiscovered.call(block_identifier=block_number)

    def get_geneis_hash(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getGeneisHash.call(block_identifier=block_number)

    def get_planet_states(
        self, locations: List, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getPlanetStates.call(
            locations, block_identifier=block_number
        )

    def acquire_via_free_token_transfer_from(
        self, location: int, amount: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.acquireViaFreeTokenTransferFrom(
            location, amount, transaction_config
        )

    def acquire_via_transfer_from(
        self, location: int, amount: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.acquireViaTransferFrom(
            location, amount, transaction_config
        )

    def balance_to_withdraw(
        self, owner: ChecksumAddress, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.balanceToWithdraw.call(
            owner, block_identifier=block_number
        )

    def exit_for(
        self, owner: ChecksumAddress, location: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.exitFor(owner, location, transaction_config)

    def fetch_and_withdraw_for(
        self, owner: ChecksumAddress, locations: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.fetchAndWithdrawFor(owner, locations, transaction_config)

    def on_token_paid_for(
        self,
        arg1: ChecksumAddress,
        for_address: ChecksumAddress,
        amount: int,
        data: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onTokenPaidFor(
            arg1, for_address, amount, data, transaction_config
        )

    def on_token_transfer(
        self, arg1: ChecksumAddress, amount: int, data: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onTokenTransfer(arg1, amount, data, transaction_config)

    def withdraw_for(self, owner: ChecksumAddress, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.withdrawFor(owner, transaction_config)

    def diamond_cut(
        self,
        _diamond_cut: List,
        _init: ChecksumAddress,
        _calldata: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.diamondCut(
            _diamond_cut, _init, _calldata, transaction_config
        )

    def owner(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.owner.call(block_identifier=block_number)

    def transfer_ownership(
        self, _new_owner: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.transferOwnership(_new_owner, transaction_config)

    def facet_address(
        self,
        _function_selector: bytes,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.facetAddress.call(
            _function_selector, block_identifier=block_number
        )

    def facet_addresses(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.facetAddresses.call(block_identifier=block_number)

    def facet_function_selectors(
        self,
        _facet: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.facetFunctionSelectors.call(
            _facet, block_identifier=block_number
        )

    def facets(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.facets.call(block_identifier=block_number)


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.max_fee_per_gas is not None:
        transaction_config["max_fee"] = args.max_fee_per_gas
    if args.max_priority_fee_per_gas is not None:
        transaction_config["priority_fee"] = args.max_priority_fee_per_gas
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        parser.add_argument(
            "--block-number",
            required=False,
            type=int,
            help="Call at the given block number, defaults to latest",
        )
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--max-fee-per-gas",
        default=None,
        help="Max fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--max-priority-fee-per-gas",
        default=None,
        help="Max priority fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )
    parser.add_argument(
        "--value", default=None, help="Value of the transaction in wei(optional)"
    )
    parser.add_argument("--verbose", action="store_true", help="Print verbose output")


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = OuterSpace(None)
    result = contract.deploy(
        _contract_owner=args.contract_owner_arg,
        _diamond_cut=args.diamond_cut_arg,
        _initializations=args.initializations_arg,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_verify_contract(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.verify_contract()
    print(result)


def handle_init(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.init(transaction_config=transaction_config)
    print(result)
    if args.verbose:
        print(result.info())


def handle_add_reward(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.add_reward(
        location=args.location,
        sponsor=args.sponsor,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_debug_reset_exit_start_time(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.debug_reset_exit_start_time(
        location=args.location, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_reset_planet(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.reset_planet(
        location=args.location, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_get_fleet(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_fleet(
        fleet_id=args.fleet_id, from_=args.from_arg, block_number=args.block_number
    )
    print(result)


def handle_resolve_fleet(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.resolve_fleet(
        fleet_id=args.fleet_id,
        # resolution=tuple(args.resolution),
        resolution=[
            args.fromPlanet,
            args.toPlanet,
            args.distance,
            args.arrivalTimeWanted,
            args.gift,
            args.specific,
            args.secret,
            args.fleetSender,
            args.operator,
        ],
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_send(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.send(
        from_=args.from_arg,
        quantity=args.quantity,
        to_hash=args.to_hash,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_send_for(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.send_for(
        launch=args.launch, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_get_planet(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_planet(location=args.location, block_number=args.block_number)
    print(result)


def handle_get_planet_state(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_planet_state(
        location=args.location, block_number=args.block_number
    )
    print(result)


def handle_get_updated_planet_state(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_updated_planet_state(
        location=args.location, block_number=args.block_number
    )
    print(result)


def handle_is_approved_for_all(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.is_approved_for_all(
        owner=args.owner, operator=args.operator, block_number=args.block_number
    )
    print(result)


def handle_owner_and_ownership_start_time_of(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.owner_and_ownership_start_time_of(
        location=args.location, block_number=args.block_number
    )
    print(result)


def handle_owner_of(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.owner_of(location=args.location, block_number=args.block_number)
    print(result)


def handle_safe_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.safe_transfer_from(
        from_=args.from_arg,
        to=args.to,
        location=args.location,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_safe_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.safe_transfer_from(
        from_=args.from_arg,
        to=args.to,
        location=args.location,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_approval_for_all(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_approval_for_all(
        operator=args.operator,
        approved=args.approved,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_approval_for_all_if_needed_and_call(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_approval_for_all_if_needed_and_call(
        operator=args.operator, data=args.data, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.transfer_from(
        from_=args.from_arg,
        to=args.to,
        location=args.location,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_get_alliance_registry(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_alliance_registry(block_number=args.block_number)
    print(result)


def handle_get_discovered(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_discovered(block_number=args.block_number)
    print(result)


def handle_get_geneis_hash(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_geneis_hash(block_number=args.block_number)
    print(result)


def handle_get_planet_states(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.get_planet_states(
        locations=args.locations, block_number=args.block_number
    )
    print(result)


def handle_acquire_via_free_token_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.acquire_via_free_token_transfer_from(
        location=args.location,
        amount=args.amount,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_acquire_via_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.acquire_via_transfer_from(
        location=args.location,
        amount=args.amount,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_balance_to_withdraw(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.balance_to_withdraw(
        owner=args.owner, block_number=args.block_number
    )
    print(result)


def handle_exit_for(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.exit_for(
        owner=args.owner, location=args.location, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_fetch_and_withdraw_for(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.fetch_and_withdraw_for(
        owner=args.owner,
        locations=args.locations,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_on_token_paid_for(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_token_paid_for(
        arg1=args.arg1,
        for_address=args.for_address,
        amount=args.amount,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_on_token_transfer(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_token_transfer(
        arg1=args.arg1,
        amount=args.amount,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_withdraw_for(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.withdraw_for(
        owner=args.owner, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_diamond_cut(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.diamond_cut(
        _diamond_cut=args.diamond_cut_arg,
        _init=args.init_arg,
        _calldata=args.calldata_arg,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_owner(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.owner(block_number=args.block_number)
    print(result)


def handle_transfer_ownership(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.transfer_ownership(
        _new_owner=args.new_owner_arg, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_facet_address(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.facet_address(
        _function_selector=args.function_selector_arg, block_number=args.block_number
    )
    print(result)


def handle_facet_addresses(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.facet_addresses(block_number=args.block_number)
    print(result)


def handle_facet_function_selectors(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.facet_function_selectors(
        _facet=args.facet_arg, block_number=args.block_number
    )
    print(result)


def handle_facets(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = OuterSpace(args.address)
    result = contract.facets(block_number=args.block_number)
    print(result)


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for OuterSpace")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.add_argument(
        "--contract-owner-arg", required=True, help="Type: address"
    )
    deploy_parser.add_argument(
        "--diamond-cut-arg", required=True, help="Type: tuple[]", nargs="+"
    )
    deploy_parser.add_argument(
        "--initializations-arg", required=True, help="Type: tuple[]", nargs="+"
    )
    deploy_parser.set_defaults(func=handle_deploy)

    verify_contract_parser = subcommands.add_parser("verify-contract")
    add_default_arguments(verify_contract_parser, False)
    verify_contract_parser.set_defaults(func=handle_verify_contract)

    init_parser = subcommands.add_parser("init")
    add_default_arguments(init_parser, True)
    init_parser.set_defaults(func=handle_init)

    add_reward_parser = subcommands.add_parser("add-reward")
    add_default_arguments(add_reward_parser, True)
    add_reward_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    add_reward_parser.add_argument("--sponsor", required=True, help="Type: address")
    add_reward_parser.set_defaults(func=handle_add_reward)

    debug_reset_exit_start_time_parser = subcommands.add_parser(
        "debug-reset-exit-start-time"
    )
    add_default_arguments(debug_reset_exit_start_time_parser, True)
    debug_reset_exit_start_time_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    debug_reset_exit_start_time_parser.set_defaults(
        func=handle_debug_reset_exit_start_time
    )

    reset_planet_parser = subcommands.add_parser("reset-planet")
    add_default_arguments(reset_planet_parser, True)
    reset_planet_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    reset_planet_parser.set_defaults(func=handle_reset_planet)

    get_fleet_parser = subcommands.add_parser("get-fleet")
    add_default_arguments(get_fleet_parser, False)
    get_fleet_parser.add_argument(
        "--fleet-id", required=True, help="Type: uint256", type=int
    )
    get_fleet_parser.add_argument(
        "--from-arg", required=True, help="Type: uint256", type=int
    )
    get_fleet_parser.set_defaults(func=handle_get_fleet)

    resolve_fleet_parser = subcommands.add_parser("resolve-fleet")
    add_default_arguments(resolve_fleet_parser, True)
    resolve_fleet_parser.add_argument(
        "--fleet-id", required=True, help="Type: uint256", type=int
    )
    # resolve_fleet_parser.add_argument("--resolution", required=True, nargs='+', help="Type: tuple(fromPlanet,toPlanet,distance,arrivalTimeWanted,gift,specific,secret,fleetSender,operator)")

    resolve_fleet_parser.add_argument("--fromPlanet")
    resolve_fleet_parser.add_argument("--toPlanet")
    resolve_fleet_parser.add_argument("--distance")
    resolve_fleet_parser.add_argument("--arrivalTimeWanted")
    resolve_fleet_parser.add_argument("--gift", type=boolean_argument_type)
    resolve_fleet_parser.add_argument("--specific")
    resolve_fleet_parser.add_argument("--secret")
    resolve_fleet_parser.add_argument("--fleetSender")
    resolve_fleet_parser.add_argument("--operator")

    resolve_fleet_parser.set_defaults(func=handle_resolve_fleet)

    send_parser = subcommands.add_parser("send")
    add_default_arguments(send_parser, True)
    send_parser.add_argument(
        "--from-arg", required=True, help="Type: uint256", type=int
    )
    send_parser.add_argument("--quantity", required=True, help="Type: uint32", type=int)
    send_parser.add_argument(
        "--to-hash", required=True, help="Type: bytes32", type=bytes_argument_type
    )
    send_parser.set_defaults(func=handle_send)

    send_for_parser = subcommands.add_parser("send-for")
    add_default_arguments(send_for_parser, True)
    send_for_parser.add_argument(
        "--launch",
        required=True,
        nargs="+",
        help="Type: tuple(fleetSender,fleetOwner,from,quantity,toHash)",
    )
    send_for_parser.set_defaults(func=handle_send_for)

    get_planet_parser = subcommands.add_parser("get-planet")
    add_default_arguments(get_planet_parser, False)
    get_planet_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    get_planet_parser.set_defaults(func=handle_get_planet)

    get_planet_state_parser = subcommands.add_parser("get-planet-state")
    add_default_arguments(get_planet_state_parser, False)
    get_planet_state_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    get_planet_state_parser.set_defaults(func=handle_get_planet_state)

    get_updated_planet_state_parser = subcommands.add_parser("get-updated-planet-state")
    add_default_arguments(get_updated_planet_state_parser, False)
    get_updated_planet_state_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    get_updated_planet_state_parser.set_defaults(func=handle_get_updated_planet_state)

    is_approved_for_all_parser = subcommands.add_parser("is-approved-for-all")
    add_default_arguments(is_approved_for_all_parser, False)
    is_approved_for_all_parser.add_argument(
        "--owner", required=True, help="Type: address"
    )
    is_approved_for_all_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    is_approved_for_all_parser.set_defaults(func=handle_is_approved_for_all)

    owner_and_ownership_start_time_of_parser = subcommands.add_parser(
        "owner-and-ownership-start-time-of"
    )
    add_default_arguments(owner_and_ownership_start_time_of_parser, False)
    owner_and_ownership_start_time_of_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    owner_and_ownership_start_time_of_parser.set_defaults(
        func=handle_owner_and_ownership_start_time_of
    )

    owner_of_parser = subcommands.add_parser("owner-of")
    add_default_arguments(owner_of_parser, False)
    owner_of_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    owner_of_parser.set_defaults(func=handle_owner_of)

    safe_transfer_from_parser = subcommands.add_parser("safe-transfer-from")
    add_default_arguments(safe_transfer_from_parser, True)
    safe_transfer_from_parser.add_argument(
        "--from-arg", required=True, help="Type: address"
    )
    safe_transfer_from_parser.add_argument("--to", required=True, help="Type: address")
    safe_transfer_from_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    safe_transfer_from_parser.set_defaults(func=handle_safe_transfer_from)

    safe_transfer_from_parser = subcommands.add_parser("safe-transfer-from")
    add_default_arguments(safe_transfer_from_parser, True)
    safe_transfer_from_parser.add_argument(
        "--from-arg", required=True, help="Type: address"
    )
    safe_transfer_from_parser.add_argument("--to", required=True, help="Type: address")
    safe_transfer_from_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    safe_transfer_from_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    safe_transfer_from_parser.set_defaults(func=handle_safe_transfer_from)

    set_approval_for_all_parser = subcommands.add_parser("set-approval-for-all")
    add_default_arguments(set_approval_for_all_parser, True)
    set_approval_for_all_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    set_approval_for_all_parser.add_argument(
        "--approved", required=True, help="Type: bool", type=boolean_argument_type
    )
    set_approval_for_all_parser.set_defaults(func=handle_set_approval_for_all)

    set_approval_for_all_if_needed_and_call_parser = subcommands.add_parser(
        "set-approval-for-all-if-needed-and-call"
    )
    add_default_arguments(set_approval_for_all_if_needed_and_call_parser, True)
    set_approval_for_all_if_needed_and_call_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    set_approval_for_all_if_needed_and_call_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    set_approval_for_all_if_needed_and_call_parser.set_defaults(
        func=handle_set_approval_for_all_if_needed_and_call
    )

    transfer_from_parser = subcommands.add_parser("transfer-from")
    add_default_arguments(transfer_from_parser, True)
    transfer_from_parser.add_argument("--from-arg", required=True, help="Type: address")
    transfer_from_parser.add_argument("--to", required=True, help="Type: address")
    transfer_from_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    transfer_from_parser.set_defaults(func=handle_transfer_from)

    get_alliance_registry_parser = subcommands.add_parser("get-alliance-registry")
    add_default_arguments(get_alliance_registry_parser, False)
    get_alliance_registry_parser.set_defaults(func=handle_get_alliance_registry)

    get_discovered_parser = subcommands.add_parser("get-discovered")
    add_default_arguments(get_discovered_parser, False)
    get_discovered_parser.set_defaults(func=handle_get_discovered)

    get_geneis_hash_parser = subcommands.add_parser("get-geneis-hash")
    add_default_arguments(get_geneis_hash_parser, False)
    get_geneis_hash_parser.set_defaults(func=handle_get_geneis_hash)

    get_planet_states_parser = subcommands.add_parser("get-planet-states")
    add_default_arguments(get_planet_states_parser, False)
    get_planet_states_parser.add_argument(
        "--locations", required=True, help="Type: uint256[]", nargs="+"
    )
    get_planet_states_parser.set_defaults(func=handle_get_planet_states)

    acquire_via_free_token_transfer_from_parser = subcommands.add_parser(
        "acquire-via-free-token-transfer-from"
    )
    add_default_arguments(acquire_via_free_token_transfer_from_parser, True)
    acquire_via_free_token_transfer_from_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    acquire_via_free_token_transfer_from_parser.add_argument(
        "--amount", required=True, help="Type: uint256", type=int
    )
    acquire_via_free_token_transfer_from_parser.set_defaults(
        func=handle_acquire_via_free_token_transfer_from
    )

    acquire_via_transfer_from_parser = subcommands.add_parser(
        "acquire-via-transfer-from"
    )
    add_default_arguments(acquire_via_transfer_from_parser, True)
    acquire_via_transfer_from_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    acquire_via_transfer_from_parser.add_argument(
        "--amount", required=True, help="Type: uint256", type=int
    )
    acquire_via_transfer_from_parser.set_defaults(func=handle_acquire_via_transfer_from)

    balance_to_withdraw_parser = subcommands.add_parser("balance-to-withdraw")
    add_default_arguments(balance_to_withdraw_parser, False)
    balance_to_withdraw_parser.add_argument(
        "--owner", required=True, help="Type: address"
    )
    balance_to_withdraw_parser.set_defaults(func=handle_balance_to_withdraw)

    exit_for_parser = subcommands.add_parser("exit-for")
    add_default_arguments(exit_for_parser, True)
    exit_for_parser.add_argument("--owner", required=True, help="Type: address")
    exit_for_parser.add_argument(
        "--location", required=True, help="Type: uint256", type=int
    )
    exit_for_parser.set_defaults(func=handle_exit_for)

    fetch_and_withdraw_for_parser = subcommands.add_parser("fetch-and-withdraw-for")
    add_default_arguments(fetch_and_withdraw_for_parser, True)
    fetch_and_withdraw_for_parser.add_argument(
        "--owner", required=True, help="Type: address"
    )
    fetch_and_withdraw_for_parser.add_argument(
        "--locations", required=True, help="Type: uint256[]", nargs="+"
    )
    fetch_and_withdraw_for_parser.set_defaults(func=handle_fetch_and_withdraw_for)

    on_token_paid_for_parser = subcommands.add_parser("on-token-paid-for")
    add_default_arguments(on_token_paid_for_parser, True)
    on_token_paid_for_parser.add_argument("--arg1", required=True, help="Type: address")
    on_token_paid_for_parser.add_argument(
        "--for-address", required=True, help="Type: address"
    )
    on_token_paid_for_parser.add_argument(
        "--amount", required=True, help="Type: uint256", type=int
    )
    on_token_paid_for_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_token_paid_for_parser.set_defaults(func=handle_on_token_paid_for)

    on_token_transfer_parser = subcommands.add_parser("on-token-transfer")
    add_default_arguments(on_token_transfer_parser, True)
    on_token_transfer_parser.add_argument("--arg1", required=True, help="Type: address")
    on_token_transfer_parser.add_argument(
        "--amount", required=True, help="Type: uint256", type=int
    )
    on_token_transfer_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_token_transfer_parser.set_defaults(func=handle_on_token_transfer)

    withdraw_for_parser = subcommands.add_parser("withdraw-for")
    add_default_arguments(withdraw_for_parser, True)
    withdraw_for_parser.add_argument("--owner", required=True, help="Type: address")
    withdraw_for_parser.set_defaults(func=handle_withdraw_for)

    diamond_cut_parser = subcommands.add_parser("diamond-cut")
    add_default_arguments(diamond_cut_parser, True)
    diamond_cut_parser.add_argument(
        "--diamond-cut-arg", required=True, help="Type: tuple[]", nargs="+"
    )
    diamond_cut_parser.add_argument("--init-arg", required=True, help="Type: address")
    diamond_cut_parser.add_argument(
        "--calldata-arg", required=True, help="Type: bytes", type=bytes_argument_type
    )
    diamond_cut_parser.set_defaults(func=handle_diamond_cut)

    owner_parser = subcommands.add_parser("owner")
    add_default_arguments(owner_parser, False)
    owner_parser.set_defaults(func=handle_owner)

    transfer_ownership_parser = subcommands.add_parser("transfer-ownership")
    add_default_arguments(transfer_ownership_parser, True)
    transfer_ownership_parser.add_argument(
        "--new-owner-arg", required=True, help="Type: address"
    )
    transfer_ownership_parser.set_defaults(func=handle_transfer_ownership)

    facet_address_parser = subcommands.add_parser("facet-address")
    add_default_arguments(facet_address_parser, False)
    facet_address_parser.add_argument(
        "--function-selector-arg",
        required=True,
        help="Type: bytes4",
        type=bytes_argument_type,
    )
    facet_address_parser.set_defaults(func=handle_facet_address)

    facet_addresses_parser = subcommands.add_parser("facet-addresses")
    add_default_arguments(facet_addresses_parser, False)
    facet_addresses_parser.set_defaults(func=handle_facet_addresses)

    facet_function_selectors_parser = subcommands.add_parser("facet-function-selectors")
    add_default_arguments(facet_function_selectors_parser, False)
    facet_function_selectors_parser.add_argument(
        "--facet-arg", required=True, help="Type: address"
    )
    facet_function_selectors_parser.set_defaults(func=handle_facet_function_selectors)

    facets_parser = subcommands.add_parser("facets")
    add_default_arguments(facets_parser, False)
    facets_parser.set_defaults(func=handle_facets)

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
